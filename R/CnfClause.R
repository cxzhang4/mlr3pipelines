# A clause is a disjunction of atoms.
# X %among% c("a", "b", "c") | Y %among% c("d", "e", "f")

#' @title Clauses in CNF Formulas
#'
#' @description
#' A `CnfClause` is a disjunction of [`CnfAtom`] objects. It represents a statement
#' that is true if at least one of the atoms is true. These are for example of the form
#' ```r
#'   X %among% c("a", "b", "c") | Y %among% c("d", "e", "f") | ...
#' ```
#'
#' `CnfClause` objects can be constructed explicitly, using the `CnfClause()` constructor,
#' or implicitly, by using the `|` operator on [`CnfAtom`]s or other `CnfClause` objects.
#'
#' Upon construction, the `CnfClause` is simplified by (1) removing contradictions, (2) unifying
#' atoms that refer to the same symbol, and (3) evaluating to `TRUE` if any atom is `TRUE`.
#' Note that the order of atoms in a clause is not preserved.
#'
#' Using `CnfClause()` on lists that contain other `CnfClause` objects will create
#' a clause that is the disjunction of all atoms in all clauses.
#'
#' If a `CnfClause` contains no atoms, or only `FALSE` atoms, it evaluates to `FALSE`.
#' If it contains at least one atom that is always true, the clause evaluates to `TRUE`.
#' These values can be converted to, and from, `logical(1)` values using `as.logical()`
#' and `as.CnfClause()`.
#'
#' `CnfClause` objects can be negated using the `!` operator, and combined using the
#' `&` operator. Both of these operations return a [`CnfFormula`], even if the result
#' could in principle be represented as a single `CnfClause`.
#'
#' This is part of the CNF representation tooling, which is currently considered
#' experimental; it is for internal use.
#'
#' @param atoms (`list` of ([`CnfAtom`] | `CnfClause`)) \cr
#'   A list of [`CnfAtom`] or other `CnfClause` objects.
#'   The clause represents the disjunction of these atoms.
#' @param x (any) \cr
#'   The object to be coerced to a `CnfClause` by `as.CnfClause`.
#'   Only `logical(1)`, [`CnfAtom`], and `CnfClause` itself are currently supported.
#' @return A new `CnfClause` object.
#' @examples
#' u = CnfUniverse()
#' X = CnfSymbol(u, "X", c("a", "b", "c"))
#' Y = CnfSymbol(u, "Y", c("d", "e", "f"))
#'
#' CnfClause(list(X %among% c("a", "b"), Y %among% c("d", "e")))
#' X %among% c("a", "b") | Y %among% c("d", "e")
#'
#' as.CnfClause(X %among% c("a", "b"))
#'
#' # The same symbols are unified
#' X %among% "a" | Y %among% "d" | X %among% "b"
#'
#' # tautology evaluates to TRUE
#' X %among% "a" | X %among% "b" | X %among% "c"
#'
#' # contradictions are removed
#' X %among% "a" | Y %among% character(0)
#'
#' # create CnfFormula:
#' !(X %among% "a" | Y %among% "d")
#'
#' # also a CnfFormula, even if it contains a single clause:
#' !CnfClause(list(X %among% "a"))
#' (X %among% c("a", "c") | Y %among% "d") &
#'   (X %among% c("a", "b") | Y %among% "d")
#' @family CNF representation objects
#' @keywords internal
#' @export
CnfClause = function(atoms) {
  assert_list(atoms, types = c("CnfAtom", "CnfClause"))
  if (!length(atoms)) {
    return(structure(
      FALSE,
      universe = NULL,
      class = "CnfClause"
    ))
  }
  entries = list()
  universe = attr(atoms[[1]], "universe")
  for (a in atoms) {
    if (!identical(attr(a, "universe"), universe)) {
      stop("All symbols must be in the same universe.")
    }
    if (isTRUE(a)) {
      entries = TRUE
      break
    }
    if (isFALSE(a)) {
      next
    }
    if (inherits(a, "CnfAtom")) {
      entries[[a$symbol]] = union(entries[[a$symbol]], a$values)
      if (all(get(a$symbol, universe) %in% entries[[a$symbol]])) {
        entries = TRUE
        break
      }
    } else {
      # union  with another CnfClause objects
      for (sym in names(a)) {
        entries[[sym]] = union(entries[[sym]], a[[sym]])
        if (all(get(sym, universe) %in% entries[[sym]])) {
          entries = TRUE
          break
        }
      }
    }
  }
  structure(
    if (!length(entries)) FALSE else entries,
    universe = universe,
    class = "CnfClause"
  )
}

#' @export
print.CnfClause = function(x, ...) {
  if (isTRUE(x)) {
    cat("CnfClause: TRUE\n")
  } else if (isFALSE(x)) {
    cat("CnfClause: FALSE\n")
  } else {
    cat("CnfClause:\n")
    elements = map_chr(names(x), function(sym) {
      sprintf("%s \U2208 {%s}", sym, paste(x[[sym]], collapse = ", "))
    })
    cat(strwrap(paste(elements, collapse = " | "), prefix = "  "), sep = "\n")
  }
  invisible(x)
}

#' @export
format.CnfClause = function(x, ...) {
  if (isTRUE(x)) {
    return("CnfClause: T")
  } else if (isFALSE(x)) {
    return("CnfClause: F")
  } else {
    return(sprintf("CnfClause(%s)", length(x)))
  }
}

#' @rdname CnfClause
#' @export
as.CnfClause = function(x) {
  UseMethod("as.CnfClause")
}

#' @export
as.CnfClause.default = function(x) {
  stop("Cannot convert object to CnfClause.")
}

#' @export
as.CnfClause.logical = function(x) {
  assert_flag(x)
  return(structure(
    x,
    universe = attr(x, "universe"),
    class = "CnfClause"
  ))
}

#' @export
as.CnfClause.CnfAtom = function(x) {
  CnfClause(list(x))
}

#' @export
as.CnfClause.CnfClause = function(x) {
  x
}

#' @export
as.logical.CnfClause = function(x) {
  if (is.logical(x)) {
    return(unclass(x))
  }
  return(NA)
}

#' @export
all.equal.CnfClause = function(target, current, ...) {
  if (is.logical(target) && is.logical(current)) {
    # compare truth-values directly, even if they disagree on universe
    # (since logical atoms sometimes have universe set to NULL)
    if (identical(c(target), c(current))) {
      return(TRUE)
    }
    return("target and current are both logicals but not equal")
  }
  if (is.logical(target) || is.logical(current)) {
    return("target and current are not both logicals")
  }
  if (!inherits(current, "CnfClause")) {
    return("current is not a CnfClause")
  }

  normalize = function(clause) {
    # []-assign to preserve class and attributes
    clause[] = lapply(clause[order(names(clause))], sort)
  }

  target = normalize(target)
  current = normalize(current)

  all.equal.list(target, current, ...)
}

#' @rawNamespace if (getRversion() >= "4.3.0") S3method(chooseOpsMethod,CnfClause)
chooseOpsMethod.CnfClause <- function(x, y, mx, my, cl, reverse) TRUE

#' @export
`&.CnfClause` = function(e1, e2) {
  if (isFALSE(e1)) return(e1)
  if (isFALSE(e2)) return(e2)
  if (isTRUE(e1)) return(e2)
  if (isTRUE(e2)) return(e1)
  if (inherits(e2, "CnfAtom")) {
    e2 = CnfClause(list(e2))
  }
  if (inherits(e2, "CnfClause")) {
    CnfFormula(list(e1, e2))
  } else {
    # e2 is anything else -- go the lazy route
    as.CnfFormula(e1) & as.CnfFormula(e2)
  }
}

#' @export
`|.CnfClause` = function(e1, e2) {
  if (isFALSE(e1)) return(e2)
  if (isFALSE(e2)) return(e1)
  if (isTRUE(e1)) return(e1)
  if (isTRUE(e2)) return(e2)
  if (inherits(e2, "CnfAtom")) {
    e2 = CnfClause(list(e2))
  }
  if (inherits(e2, "CnfClause")) {
    for (sym in names(e2)) {
      e1[[sym]] = union(e1[[sym]], e2[[sym]])
      if (all(get(sym, attr(e1, "universe")) %in% e1[[sym]])) {
        return(structure(
          TRUE,
          universe = attr(e1, "universe"),
          class = "CnfClause"
        ))
      }
    }
    return(e1)
  }
  # e2 is anything else -- go the lazy route
  as.CnfFormula(e1) | as.CnfFormula(e2)
}


#' @export
`!.CnfClause` = function(x) {
  if (is.logical(x)) {
    return(as.CnfClause(!unclass(x)))
  }
  !as.CnfFormula(x)
}

